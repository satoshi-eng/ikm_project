import os


class Book:
    def __init__(self, author: str, title: str, publisher: str,
                 year: int, pages: int, copies: int):
        self.author = author
        self.title = title
        self.publisher = publisher
        self.year = year
        self.pages = pages
        self.copies = copies

    def __str__(self):
        return f"{self.author:20} | {self.title:25} | {self.publisher:15} | " \
               f"{self.year:4} | {self.pages:4} стр. | {self.copies:3} экз."

    def __eq__(self, other):
        if not isinstance(other, Book):
            return False
        return (self.author == other.author and
                self.title == other.title and
                self.publisher == other.publisher and
                self.year == other.year)


class Library:
    def __init__(self, filename: str = "books.txt"):
        self.filename = filename
        self.books = []
        if os.path.exists(self.filename):
            self.load_from_file()
        else:
            print(f"Файл '{self.filename}' не найден. Программа будет работать без данных.")
            print("Пожалуйста, создайте файл books.txt с данными о книгах.")
            print("Формат каждой строки: Автор;Название;Издательство;Год;Страниц;Экземпляров")

    def load_from_file(self):
        """Загрузить книги из текстового файла"""
        self.books = []
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                lines = f.readlines()

                for i, line in enumerate(lines, 1):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        if ';' in line:
                            parts = line.split(';')
                        else:
                            if ',' in line:
                                parts = line.split(',')
                            elif '\t' in line:
                                parts = line.split('\t')
                            else:
                                print(f"Пропущена строка {i}: неправильный формат")
                                continue

                        if len(parts) >= 6:
                            try:
                                author = parts[0].strip()
                                title = parts[1].strip()
                                publisher = parts[2].strip()
                                year = int(parts[3].strip())
                                pages = int(parts[4].strip())
                                copies = int(parts[5].strip())

                                self.books.append(Book(author, title, publisher, year, pages, copies))
                            except ValueError as e:
                                print(f"Ошибка в строке {i}: {e}")
                                continue
                        else:
                            print(f"Пропущена строка {i}: недостаточно данных (нужно 6 полей)")

            print(f"Загружено {len(self.books)} книг из файла '{self.filename}'")

        except Exception as e:
            print(f"Ошибка при чтении файла: {e}")
            self.books = []

    def save_to_file(self):
        """Сохранить книги в текстовый файл"""
        try:
            with open(self.filename, 'w', encoding='utf-8') as f:
                for book in self.books:
                    line = f"{book.author};{book.title};{book.publisher};" \
                           f"{book.year};{book.pages};{book.copies}\n"
                    f.write(line)
            print(f"Данные сохранены в файл '{self.filename}'")
        except Exception as e:
            print(f"Ошибка при сохранении файла: {e}")

    def add_book(self, book):
        """Добавить книгу в библиотеку"""
        self.books.append(book)
        print(f"Книга '{book.title}' добавлена в библиотеку")

    def remove_book(self, author, title, publisher, year):
        """Удалить книгу из библиотеки"""
        for i, book in enumerate(self.books):
            if (book.author == author and
                    book.title == title and
                    book.publisher == publisher and
                    book.year == year):
                removed_book = self.books.pop(i)
                print(f"Книга '{removed_book.title}' удалена из библиотеки")
                return True
        print("Книга не найдена")
        return False

    # Реализация пирамидальной сортировки
    def _heapify(self, arr, n, i, compare_func):
        """Вспомогательная функция для создания кучи"""
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and compare_func(arr[left], arr[largest]) > 0:
            largest = left

        if right < n and compare_func(arr[right], arr[largest]) > 0:
            largest = right

        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            self._heapify(arr, n, largest, compare_func)

    def heap_sort(self, arr, compare_func):
        """Пирамидальная сортировка"""
        if not arr:
            return arr

        n = len(arr)

        # Построение max-heap
        for i in range(n // 2 - 1, -1, -1):
            self._heapify(arr, n, i, compare_func)

        # Извлечение элементов из кучи
        for i in range(n - 1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]
            self._heapify(arr, i, 0, compare_func)

        return arr

    def get_full_sorted_list(self):
        """Полный список книг, отсортированный по автору (↑), году (↓), количеству экземпляров (↓)"""
        if not self.books:
            return []

        def compare_books(a, b):
            if a.author != b.author:
                return -1 if a.author < b.author else 1

            if a.year != b.year:
                return 1 if a.year < b.year else -1

            if a.copies != b.copies:
                return 1 if a.copies < b.copies else -1

            return 0

        return self.heap_sort(self.books.copy(), compare_books)

    def get_books_by_author(self, author):
        """Список книг определенного автора, отсортированный по издательству (↓) и названию (↑)"""
        if not self.books:
            return []

        author_books = []
        for book in self.books:
            if book.author == author:
                author_books.append(book)

        if not author_books:
            return []

        def compare_books(a, b):
            if a.publisher != b.publisher:
                return 1 if a.publisher < b.publisher else -1

            if a.title != b.title:
                return -1 if a.title < b.title else 1

            return 0

        return self.heap_sort(author_books, compare_books)

    def get_books_by_years_range(self, n1, n2):
        """Список книг, выпущенных в период с N1 до N2 года,
        отсортированный по году выпуска (↓) и автору (↑)"""
        if not self.books:
            return []

        filtered_books = []
        for book in self.books:
            if n1 <= book.year <= n2:
                filtered_books.append(book)

        if not filtered_books:
            return []

        def compare_books(a, b):
            if a.year != b.year:
                return 1 if a.year < b.year else -1

            if a.author != b.author:
                return -1 if a.author < b.author else 1

            return 0

        return self.heap_sort(filtered_books, compare_books)


def print_books(books, title):
    """Вывести список книг с заголовком"""
    print(f"\n{'=' * 100}")
    print(f"{title} (всего: {len(books)})")
    print('=' * 100)
    if books:
        print(f"{'Автор':20} | {'Название':25} | {'Издательство':15} | {'Год':4} | {'Страниц':7} | {'Экз.':5}")
        print('-' * 100)

        for book in books:
            print(book)
    else:
        print("Книги не найдены или база данных пуста")


def print_menu():
    """Вывести меню программы"""
    print("\n" + "=" * 60)
    print("БИБЛИОТЕКА - система управления книгами")
    print("=" * 60)
    print("1. Показать все книги (отчет 1)")
    print("2. Найти книги по автору (отчет 2)")
    print("3. Найти книги по году выпуска (отчет 3)")
    print("4. Добавить новую книгу")
    print("5. Удалить книгу")
    print("6. Обновить данные из файла")
    print("7. Сохранить данные в файл")
    print("8. Показать информацию о базе данных")
    print("9. Выход")
    print("-" * 60)


def add_book_interactive(library):
    """Интерактивное добавление книги"""
    print("\n" + "=" * 60)
    print("ДОБАВЛЕНИЕ НОВОЙ КНИГИ")
    print("=" * 60)

    try:
        author = input("Автор: ")
        if not author:
            print("Ошибка: автор не может быть пустым")
            return

        title = input("Название: ")
        if not title:
            print("Ошибка: название не может быть пустым")
            return

        publisher = input("Издательство: ")
        if not publisher:
            print("Ошибка: издательство не может быть пустым")
            return

        year = int(input("Год выпуска: "))
        if year < 0 or year > 2100:
            print("Ошибка: неверный год")
            return

        pages = int(input("Количество страниц: "))
        if pages <= 0:
            print("Ошибка: количество страниц должно быть положительным")
            return

        copies = int(input("Количество экземпляров: "))
        if copies < 0:
            print("Ошибка: количество экземпляров не может быть отрицательным")
            return

        new_book = Book(author, title, publisher, year, pages, copies)
        library.add_book(new_book)

        # Сохраняем в файл
        save_choice = input("Сохранить изменения в файл? (y/n): ")
        if save_choice.lower() == 'y':
            library.save_to_file()

    except ValueError as e:
        print(f"Ошибка ввода: {e}")
    except Exception as e:
        print(f"Ошибка: {e}")


def remove_book_interactive(library):
    """Интерактивное удаление книги"""
    if not library.books:
        print("База данных пуста. Нечего удалять.")
        return

    print("\n" + "=" * 60)
    print("УДАЛЕНИЕ КНИГИ")
    print("=" * 60)

    print("Список книг:")
    for i, book in enumerate(library.books, 1):
        print(f"{i:3}. {book.author:20} | {book.title:25} | {book.publisher:15} | {book.year}")

    try:
        choice = input("\nВыберите способ удаления:\n1. По номеру из списка\n2. По параметрам\nВаш выбор (1/2): ")

        if choice == '1':
            book_num = int(input("Введите номер книги для удаления: "))
            if 1 <= book_num <= len(library.books):
                removed_book = library.books.pop(book_num - 1)
                print(f"Книга '{removed_book.title}' удалена из библиотеки")

                save_choice = input("Сохранить изменения в файл? (y/n): ")
                if save_choice.lower() == 'y':
                    library.save_to_file()
            else:
                print("Неверный номер книги")

        elif choice == '2':
            print("\nВведите параметры книги для удаления:")
            author = input("Автор: ")
            title = input("Название: ")
            publisher = input("Издательство: ")
            year = int(input("Год выпуска: "))

            if library.remove_book(author, title, publisher, year):
                save_choice = input("Сохранить изменения в файл? (y/n): ")
                if save_choice.lower() == 'y':
                    library.save_to_file()

        else:
            print("Неверный выбор")

    except ValueError as e:
        print(f"Ошибка ввода: {e}")
    except Exception as e:
        print(f"Ошибка: {e}")


def show_database_info(library):
    """Показать информацию о базе данных"""
    print("\n" + "=" * 60)
    print("ИНФОРМАЦИЯ О БАЗЕ ДАННЫХ БИБЛИОТЕКИ")
    print("=" * 60)

    if not library.books:
        print("База данных пуста")
        return

    print(f"Всего книг: {len(library.books)}")

    authors = {}
    for book in library.books:
        if book.author in authors:
            authors[book.author] += 1
        else:
            authors[book.author] = 1

    print(f"\nВсего авторов: {len(authors)}")
    print("Количество книг по авторам:")
    for author, count in sorted(authors.items()):
        print(f"  {author}: {count} книг")

    years = {}
    for book in library.books:
        if book.year in years:
            years[book.year] += 1
        else:
            years[book.year] = 1

    print(f"\nДиапазон годов: от {min(years.keys())} до {max(years.keys())}")
    print("Количество книг по годам:")
    for year in sorted(years.keys()):
        print(f"  {year}: {years[year]} книг")

    total_pages = sum(book.pages for book in library.books)
    total_copies = sum(book.copies for book in library.books)
    print(f"\nОбщее количество страниц: {total_pages}")
    print(f"Общее количество экземпляров: {total_copies}")

    if os.path.exists(library.filename):
        file_size = os.path.getsize(library.filename)
        print(f"\nФайл данных: {library.filename}")
        print(f"Размер файла: {file_size} байт")


def main():
    library = Library("books.txt")

    if library.books:
        print("\n" + "=" * 60)
        print("ДОБРО ПОЖАЛОВАТЬ В СИСТЕМУ УПРАВЛЕНИЯ БИБЛИОТЕКОЙ")
        print("=" * 60)
        print(f"Загружено {len(library.books)} книг из файла 'books.txt'")
        print("Для просмотра отчетов выберите пункты 1-3 в меню")
    else:
        print("\nВнимание: База данных пуста.")
        print("Создайте файл books.txt или добавьте книги через меню.")

    while True:
        print_menu()
        choice = input("\nВыберите действие (1-9): ")

        if choice == '1':
            # Отчет 1
            sorted_books = library.get_full_sorted_list()
            print_books(sorted_books,
                        "ПОЛНЫЙ СПИСОК ВСЕХ КНИГ (Автор↑, Год↓, Экз.↓)")

        elif choice == '2':
            # Отчет 2
            if library.books:
                authors = sorted(set(book.author for book in library.books))
                print("\nДоступные авторы:")
                for i, author in enumerate(authors, 1):
                    print(f"{i}. {author}")

                author_input = input("\nВведите фамилию автора или номер: ")
                if author_input.isdigit():
                    idx = int(author_input) - 1
                    if 0 <= idx < len(authors):
                        author_input = authors[idx]
                    else:
                        print("Неверный номер")
                        continue

                author_books = library.get_books_by_author(author_input)
                print_books(author_books,
                            f"КНИГИ АВТОРА: {author_input} (Издательство↓, Название↑)")
            else:
                print("База данных пуста.")

        elif choice == '3':
            # Отчет 3
            if library.books:
                years = sorted(set(book.year for book in library.books))
                print(f"\nДоступные годы: от {years[0]} до {years[-1]}")

                try:
                    n1 = int(input("Введите начальный год (N1): "))
                    n2 = int(input("Введите конечный год (N2): "))

                    if n1 > n2:
                        n1, n2 = n2, n1
                        print(f"Годы поменяны местами: {n1}-{n2}")

                    year_books = library.get_books_by_years_range(n1, n2)
                    print_books(year_books,
                                f"КНИГИ ЗА ПЕРИОД {n1}-{n2} (Год↓, Автор↑)")

                except ValueError:
                    print("Ошибка: введите корректные годы")
            else:
                print("База данных пуста.")

        elif choice == '4':
            add_book_interactive(library)

        elif choice == '5':
            remove_book_interactive(library)

        elif choice == '6':
            if os.path.exists("books.txt"):
                library.load_from_file()
            else:
                print("Файл books.txt не найден.")

        elif choice == '7':
            if library.books:
                library.save_to_file()
            else:
                print("Нет данных для сохранения.")

        elif choice == '8':
            show_database_info(library)

        elif choice == '9':
            print("\nСпасибо за использование системы управления библиотекой!")
            print("Выход из программы.")
            break

        else:
            print("Неверный выбор. Попробуйте снова.")

        input("\nНажмите Enter для продолжения...")


if __name__ == "__main__":
    main()
